
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.45">
    
    
      
        <title>研究生入学考试训练录</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.0253249f.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#408" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="研究生入学考试训练录" class="md-header__button md-logo" aria-label="研究生入学考试训练录" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            研究生入学考试训练录
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              408 计算机学科专业基础
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="研究生入学考试训练录" class="md-nav__button md-logo" aria-label="研究生入学考试训练录" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    研究生入学考试训练录
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    408 计算机学科专业基础
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    408 计算机学科专业基础
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      更新日志
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      待办事项
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      写在前面的话
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      更新日志
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      待办事项
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      写在前面的话
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="408">408 计算机学科专业基础</h1>
<blockquote>
<p>MIT License Copyright (c) 2024 Lemon_Tree_408考研版权所有</p>
<p>本文默认读者具有基本普通计算机知识能力。目前全部标题全部对标考纲。紫色注意内容也是考纲原文。</p>
<p>本文件尊崇，开源开放共享精神</p>
</blockquote>
<p><img src="/img/截图/截屏2024-11-18 20.29.29.png" alt="124140926_p0" width= "50%" hight = "50%" /></p>
<h2 id="_1">更新日志</h2>
<blockquote>
<p>版本 v1.0 2024 11 18 初步创建该笔记 </p>
<p>版本v1.1 2024 11 19 更新了虚拟文件系统VFS，写在前面的话，中断基础。</p>
<p>版本v1.2 2024 11 20 更新了OS引导，操作系统结构，实模式下的中断</p>
<p>版本v1.3 2024 11 21 更新了 内存保护，虚拟内存，伙伴系统，页面置换算法</p>
<p>版本v1.4 2024 11 22 更新了 flash存储器 更新CISC RISC</p>
<p>版本v1.5 2024 11 24 更新了外存管理</p>
</blockquote>
<h2 id="_2">待办事项</h2>
<blockquote>
<p>[!WARNING]</p>
<p>IEEE754</p>
<p>计算机网络</p>
<p>进一步拓展内容如何处理未知。</p>
<p>有大主题可以串全部的知识点。思考是否单独成章如（操作系统引导，磁盘访问）</p>
<p>笔记&gt;咸鱼p p t &gt;教材 &gt; ppt  &gt;&gt; wd书 &gt; 知乎</p>
</blockquote>
<h2 id="_3">写在前面的话</h2>
<blockquote>
<p>我自己重新对着大纲学。我发现我好多都没搞懂。现在大概知道了。就是一定要看大纲。我为什么要学这些。要看到智慧，与悟道。</p>
<p>笔者疑似迷失在了408的花园里，笔者往图书馆一坐就是一天，竟然不知时间流逝，大概已经疯了。</p>
<p>取自与群友对话。我感觉学408就是一定要实用。比如，我访问一个外存磁盘，到底是怎么访问的。这是一个非常巨大的问题。然后根据这个问题，你可以理清思路。</p>
<p>问：总线是什么，考打你。别看书，回答一下。定义是什么。答，在cpu与其他部件间传输数据的。问：因为一开始用的是专用数据通路，每个设备间都连线。计算机发展了。要加硬件。部线量太大了。所以使用总线。很多设备都连到几根线上。节约成本，方便扩展。但是你要连上去就有冲突等。然后就要开始设计。</p>
<p>还有就是比如学一个东西，一定要知道他是干什么的。为什么要这么设计。有什么好处，解决了什么问题。</p>
<p>你如何让一个硬件运行呢。</p>
</blockquote>
<h1 id="_4">数据结构</h1>
<blockquote>
<p>可视化</p>
<p>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</p>
</blockquote>
<h1 id="1">1 基本概念</h1>
<h2 id="11">1.1 数据结构的基本概念</h2>
<h2 id="12">1.2 算法的基本概念</h2>
<p><img alt="截屏2024-11-18 20.29.29" src="/img/截图/截屏2024-11-18 20.29.29.png" /></p>
<p><img alt="截屏2024-11-18 20.32.09" src="/Users/apple/Desktop/截图/截屏2024-11-18 20.32.09.png" /></p>
<h1 id="4">4 树与二叉树</h1>
<h2 id="42">4.2 二叉树</h2>
<h3 id="432">4.3.2 森林与二叉树的转换</h3>
<p><img alt="截屏2024-11-19 13.58.22" src="/Users/apple/Desktop/截图/截屏2024-11-19 13.58.22.png" /></p>
<p><img alt="截屏2024-11-19 13.59.06" src="/Users/apple/Desktop/截图/截屏2024-11-19 13.59.06.png" /></p>
<h3 id="433">4.3.3 树和森林的遍历</h3>
<p><img alt="截屏2024-11-19 14.01.01" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.01.01.png" /></p>
<p><img alt="截屏2024-11-19 14.21.01" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.21.01.png" /></p>
<p><img alt="截屏2024-11-19 14.21.41" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.21.41.png" /></p>
<p><img alt="截屏2024-11-19 14.18.05" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.18.05.png" /></p>
<p><img alt="截屏2024-11-19 14.20.13" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.20.13.png" /></p>
<h2 id="44">4.4 树与二叉树的应用</h2>
<h3 id="441-huffman">4.4.1 哈夫曼(Huffman)树和哈夫曼编码</h3>
<p><img alt="截屏2024-11-19 14.38.57" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.38.57.png" /></p>
<p><img alt="截屏2024-11-19 14.42.32" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.42.32.png" /></p>
<p><img alt="截屏2024-11-19 14.39.13" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.39.13.png" /></p>
<p><img alt="截屏2024-11-19 14.41.52" src="/Users/apple/Desktop/截图/截屏2024-11-19 14.41.52.png" /></p>
<h3 id="442">4.4.2 并查集及其应用</h3>
<h3 id="443">4.4.3 堆及其应用</h3>
<h1 id="_5">计算机组成原理</h1>
<p><img src="/Users/apple/Desktop/截图/001a762615c6c56990ab55187158178d.png" alt="001a762615c6c56990ab55187158178d" width= "50%" /></p>
<h1 id="1_1">1 计算机系统概述</h1>
<h2 id="11_1">1.1 计算机层次结构</h2>
<h3 id="111">1.1.1 计算机系统的基本组成</h3>
<p><img alt="截屏2024-11-22 13.10.37" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.10.37.png" /></p>
<p><img alt="截屏2024-11-22 13.10.48" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.10.48.png" /></p>
<h3 id="112">1.1.2 计算机硬件的基本结构</h3>
<p><img alt="截屏2024-11-22 13.13.38" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.13.38.png" /></p>
<p><img alt="截屏2024-11-22 13.13.53" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.13.53.png" /></p>
<p><img alt="截屏2024-11-22 13.14.02" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.14.02.png" /></p>
<h3 id="113">1.1.3 计算机软件和硬件的关系</h3>
<blockquote>
<p>疑似思考整个体系</p>
</blockquote>
<p><img alt="截屏2024-11-22 13.38.03" src="/Users/apple/Desktop/截图/截屏2024-11-22 13.38.03.png" /></p>
<p>高级语言(high-level language)和底层计算机结构无关,大部分编程语言都是高级语言;</p>
<p>低级语言(low-level language)则和运行程序的计算机的底层结构密切相关,通常称为机器级语言(machine-level language)。机器语言和汇编语言都是机器级语言。</p>
<p>翻译程序有以下3类。 (1)汇编程序(assembler):也称汇编器,用来将汇编语言源程序翻译成机器语言目标程序。 (2)解释程序(interpreter):也称解释器,用来将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行。 (3)编译程序(compiler):也称编译器,用来将高级语言源程序翻译成汇编语言或机器语言目标程序。</p>
<p>所有的语言处理系统都必须在操作系统提供的计算机环境中运行,操作系统是对计算机底层结构和计算机硬件的一种抽象,这种抽象构成了一台可以让程序员使用的虚拟机(virtual machine)。</p>
<p>指令集体系结构(instruction set architecture)</p>
<p>有时也称为指令系统或指令集架构。它是软件和硬件之间接口的一个完整定义。ISA定义了一台计算机可以执行的所有指令的集合,每条指令规定了计算机执行什么操作,所处理的操作数所存放的位置以及操作数的类型等。ISA 规定的内容包括指令格式、指令操作类型,指令的操作数类型、寻址方式和可访问地址空间大小,程序可访问的寄存器个数、位数和编号,控制寄存器的定义,I/O空间的编址方式,中断结构,机器工作状态的定义和切换,输入/输出结构和数据传送方式,存储保护方式等。</p>
<p>因此,指令集体系结构是指软件能感知到的部分,也称软件可见部分。</p>
<p>微体系结构</p>
<p>ISA是对指令系统的一种规定或结构规范,而具体实现的组织(organization)称为微体系结构(microarchitecture),简称微架构。ISA和微体系结构是两个不同层面上的概念,微体系结构是软件不可感知的部分。加法器采用串行进位方式还是并行进位方式实现属于微体系结构范畴。相同的ISA可能具有不同的微体系结构</p>
<p>微体系结构由逻辑电路(logic circuit)实现。每个基本的逻辑电路都是按照特定的器件技术(device technology)实现的。</p>
<p>ISA层下面是硬件部分,上面是软件部分。硬件部分包括 CPU、主存和输入/输出等主要功能部件,这些功能部件通过数字逻辑电路设计实现。软件部分包括低层的系统软件和高层的应用软件,汇编程序、编译程序和操作系统等这些系统软件直接在ISA上实现,系统程序员所看到的机器的属性是属于ISA层面的内容,所看到的机器是配置了指令系统的机器,称为机器语言机器,工作在该层次的程序员称为机器语言程序员;系统管理员工作在操作系统层,所看到的是配置了操作系统的虚拟机器,称为操作系统虚拟机;汇编语言程序员工作在提供汇编程序的虚拟机器级,所看到的机器称为汇编语言虚拟机;应用程序员大多工作在提供编译器或解释器等翻译程序的语言处理系统层,因此,应用程序员大多用高级语言编写程序,因而也称为高级语言程序员,所看到虚拟机器称为高级语言虚拟机;最终用户则工作在最上面的应用程序层。</p>
<p><img alt="截屏2024-11-22 14.00.03" src="/Users/apple/Desktop/截图/截屏2024-11-22 14.00.03.png" /></p>
<h3 id="114">1.1.4 计算机系统的工作原理</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>1.存储程序的工作方式</p>
<p>2.高级语言程序与机器语言程序之间的转换</p>
<p>3.程序和指令的执行过程</p>
<p>高级语言程序与机器语言程序之间的转换</p>
</blockquote>
<p><img alt="截屏2024-11-22 14.18.36" src="/Users/apple/Desktop/截图/截屏2024-11-22 14.18.36.png" /></p>
<p>在图1.9中,预处理程序(cpp)对源程序中以字符#开头的命令进行处理,例如,将#include 命令后面的.h文件内容嵌入到源程序文件中。预处理程序的输出结果还是一个源程序文件,以.i为扩展名。 编译程序(ccl)对预处理后的源程序进行编译,生成一个汇编语言源程序文件,以.s为扩展名,例如,hello.s 是一个汇编语言程序文件。 汇编程序(as)对汇编语言源程序进行汇编,生成一个可重定位目标文件(relocatable objeet file),以.o为扩展名,例如,hello.o是一个可重定位目标文件;它是一种二进制文件(binary file),因为其中的代码已经是机器指令,数据以及其他信息也都用二进制表示,所以它是不可读的,即打开显示出来的是乱码。 链接程序(ld)将多个可重定位目标文件和标准库函数合并成一个可执行目标文件(executable object file),可执行目标文件简称为可执行文件。本例中,链接器将 hello.o 和标准库函数 printf所在的可重定位目标模块 printf.o进行合并,生成可执行文件 hello。 最终生成的可执行文件保存在磁盘等外存中,可以通过某种方式启动可执行文件运行。</p>
<h1 id="3">3 存储器层次结构</h1>
<h2 id="31">3.1 存储器的分类</h2>
<h2 id="32">3.2 层次化存储器的基本结构</h2>
<h2 id="33">3.3 半导体随机存取存储器</h2>
<p><img alt="截屏2024-11-23 00.54.57" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.54.57.png" /></p>
<h3 id="331-sram">3.3.1 SRAM存储器</h3>
<p><img alt="截屏2024-11-23 00.55.28" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.55.28.png" /></p>
<h3 id="332-dram">3.3.2 DRAM存储器</h3>
<p><img alt="截屏2024-11-23 00.55.22" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.55.22.png" /></p>
<h3 id="333-flash">3.3.3 Flash存储器</h3>
<p><img alt="截屏2024-11-23 12.10.17" src="/Users/apple/Desktop/截图/截屏2024-11-23 12.10.17.png" /></p>
<p><img src="/Users/apple/Desktop/截图/截屏2024-11-23 12.12.22.png" alt="截屏2024-11-23 12.12.22" style="zoom:35%;" /></p>
<p>又名电子式可清除程序化只读存储器</p>
<p>计算机中有一些相对固定的信息,需要存放在只读存储器(ROM)中,例如,系统启动时用到的 BIOS(basic input/output system,基本输入/输出系统)是永久保存在ROM中的。 早期的ROM BIOS芯片采用烧录器写入方式,一旦安装在计算机主板中,便不能更改,除非更换芯片;而现在主板都用Flash存储器芯片来存储 BIOS,可通过使用主板厂商提供的擦写程序,直接在计算机中进行擦除,然后再重新写入。</p>
<p>Flash 存储器也称为闪存,是高密度非易失性读写存储器,它兼有RAM和ROM的优点,而且功耗低、集成度高,不需后备电源。这种器件沿用了 EPROM的简单结构和浮栅/热电子注入的编程写入方式,又兼备 EEPROM的可擦除特点,且可在计算机内进行擦除和编程写入,因此又称为快擦型 EEPROM。目前被广泛使用的U盘和存储卡等都属于 Flash 存储器。</p>
<p>1.Flash 存储元Flash 存储元是在 EPROM存储元基础上发展起来的。如图7.18所示是一个 Flash 存储元,每个存储元由单个 MOS管组成,包括漏极 D、源极 S、控制栅和浮空栅。当控制栅加上足够的正电压时,浮空栅将储存大量电子,即带有许多负电荷,可将存储元的这种状态定义为0;当控制栅不加正电压,则浮空栅少带或不带负电荷,将这种状态定义为1。</p>
<p>闪存有3种基本操作:编程(充电)、擦除(放电)、读取。</p>
<p>编程操作:最初所有存储元都是1状态,通过编程,在需要改写为0的存储元的控制栅加上一个正电压Vy,如图7.19(a)所示。一旦某存储元被编程,则存储的数据可保持100年而无须外电源。</p>
<p>擦除操作:采用电擦除。即在所有存储元的源极S加正电压Vr,使浮空栅中的电子被吸收掉,从而使所有存储元都变成1状态,如图7.19(b) 所示。因此,写的过程实际上是先全部擦除,使全都变成1状态后再在需要的地方改写为0,即先全部放电,再在写0的地方充电。</p>
<p>读取操作:在控制栅加上正电压Vg,若原存为0,则如图 7.20(a)所示,读出电路检测不到电流;若原存为1,则如图7.20(b)所示,浮空栅不带负电荷,控制栅上的正电压足以开启晶体管,电源V。提供从漏极D到源极S的电流,读出电路检测到电流。</p>
<p>从上述基本原理可以看出,Flash 存储器的读操作速度和写操作速度相差很大,其读取速度与半导体RAM芯片相当,而写数据(擦除一编程)的速度则比RAM芯片慢很多。</p>
<blockquote>
<p>以下为知乎内容补充</p>
</blockquote>
<p><img alt="截屏2024-11-23 00.56.10" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.56.10.png" /></p>
<p><img alt="截屏2024-11-23 00.57.37" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.57.37.png" /></p>
<p><img alt="截屏2024-11-23 00.58.05" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.58.05.png" /></p>
<p><img alt="截屏2024-11-23 12.02.54" src="/Users/apple/Desktop/截图/截屏2024-11-23 12.02.54.png" /></p>
<p><img alt="截屏2024-11-23 12.05.04" src="/Users/apple/Desktop/截图/截屏2024-11-23 12.05.04.png" /></p>
<p>https://www.zhihu.com/pub/reader/120331914/chapter/1543189191718289408</p>
<p>https://www.zhihu.com/pub/reader/120331914/chapter/1543189234395090944</p>
<h3 id="334">3.3.4 补充内容</h3>
<p><img alt="截屏2024-11-23 00.55.45" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.55.45.png" /></p>
<h2 id="35">3.5 外部存储器</h2>
<h3 id="351">3.5.1 磁盘存储器</h3>
<h3 id="352-ssd">3.5.2 固态硬盘(SSD)</h3>
<p><img alt="截屏2024-11-23 00.27.20" src="/Users/apple/Desktop/截图/截屏2024-11-23 00.27.20.png" /></p>
<p>它也被称为电子硬盘。==这种硬盘并不是一种磁表面存储器==,而是一种使用NAND闪存组成的外部存储系统,与U盘并没有本质差别,只是容量更大,存取性能更好。</p>
<p>它用闪存颗粒代替了磁盘作为存储介质,利用闪存的特点,以区块写入和抹除的方式进行数据的读取和写入。</p>
<p>固态硬盘的接口规范和定义、功能及使用方法与传统的硬磁盘完全相同。目前接口标准使用USB,SATA和IDE,因此 SSD通过标准磁盘接口与I/O总线互连。==在SSD中有一个闪存翻译层,它将来自CPU的逻辑磁盘块读写请求翻译成对底层 SSD物理设备的读写控制信号。因此,这个闪存翻译层相当于磁盘控制器。==</p>
<p>SSD中一个闪存芯片由若干区块(block)组成,每个区块由若干页(page)组成,通常,页大小为512B～4KB,每个区块由32～128个页组成,因而区块大小为16~512KiB,数据按页为单位进行读写。==SSD有三个限制:1对某页写信息之前,必须先擦除该页所在的整个区块;2擦除后区块内的页必须按顺序写入信息;3只有有限的擦除/编程次数。==</p>
<p>某一区块进行了几千到几万次重复写之后,就会被磨损而变成坏的区块,不能再被使用。因此,闪==存翻译层中有一个专门的均化磨损(wear leveling)逻辑电路,试图将擦除操作平均分布在所有区块上,==以最大限度地延长 SSD的使用寿命。</p>
<p>==电信号的控制使得固态硬盘的内部传输速率远远高于常规硬盘。==SSD随机读时间为几十微秒,而随机写的访问时间为几百微秒。硬盘由于需要寻道和旋转等待,所以其访问时间是几毫秒到几十毫秒,因此,SSD随机读写时延比硬盘要低两个数量级。有测试显示,使用固态硬盘以后,Windows的开机速度可以被提升至20s以内,这是基于常规硬盘的计算机系统难以达到的速度性能。</p>
<h2 id="36-cache">3.6 高速缓冲存储器(Cache)</h2>
<h2 id="37">3.7 虚拟存储器</h2>
<h1 id="4_1">4 指令系统</h1>
<h2 id="41">4.1 指令系统的基本概念</h2>
<h2 id="42_1">4.2 指令格式</h2>
<h2 id="43">4.3 寻址方式</h2>
<h2 id="44_1">4.4 数据的对齐和大小端存放方式</h2>
<h2 id="45-cisc-risc">4.5 CISC 和 RISC 的基本概念</h2>
<blockquote>
<p>2009真题 25jc(3)(18)</p>
</blockquote>
<p>指令系统设计风格，按指令格式的复杂度来分。</p>
<p><img alt="截屏2024-11-23 15.23.12" src="/Users/apple/Desktop/截图/截屏2024-11-23 15.23.12.png" /></p>
<p><img alt="截屏2024-11-23 15.28.42" src="/Users/apple/Desktop/截图/截屏2024-11-23 15.28.42.png" /></p>
<p>1)CISC风格指令系统</p>
<p>随着 VLSI技术的迅速发展,计算机硬件成本不断下降,软件成本不断上升。为此,人们在设计指令系统时增加了越来越多功能强大的复杂指令,以使指令功能接近高级语言语句的功能,给软件提供较好的支持。</p>
<p>复杂的指令系统使得计算机的结构变得复杂,不仅增加了研制周期和成本,而且难以保证其正确性,甚至降低了系统性能。对大量典型的CISC程序进行了调查,结果表明,各种指令的使用频率相当悬殊,最常使用的是只占指令系统20??一些简单指令,它们占程序代码的80??上,而需要大量硬件支持的复杂指令在程序中的出现频率却很低,这造成了硬件资源的大量浪费。</p>
<p>RISC 指令系统的主要特点如下。</p>
<p>(1)指令数目少。只包含使用频度高的简单指令。 (2)指令格式规整。寻址方式少、指令格式少、指令长度一致。 (3)采用Load/Store型指令设计风格。 (4)采用流水线方式执行指令。规整的指令格式有利于采用流水线方式执行。 (5)采用大量通用寄存器。编译器可将变量分配到通用寄存器中,以减少访存次数。 (6)采用硬连线控制器。指令少而规整使得控制器的实现变得简单,可以不用或少用微程序控制。(7)采用优化的编译系统。指令数少有利于编译器的优化。</p>
<p>不过,随着后个人计算机时代的到来,个人移动设备的使用和嵌入式系统的应用越来越广泛,像 ARM处理器等这些采用RICS技术的产品又迎来了新的机遇,在嵌入式系统中占有绝对优势,因而被更广泛使用。</p>
<h2 id="46">4.6 高级语言程序与机器级代码之间的对应关系</h2>
<h3 id="461">4.6.1 编译器、汇编器和链接器的基本概念</h3>
<h3 id="462">4.6.2 选择结构语句的机器级表示</h3>
<h3 id="463">4.6.3 循环结构语句的机器级表示</h3>
<h3 id="464">4.6.4 过程(函数)调用对应的机器级表示</h3>
<h1 id="5-cpu">5 中央处理器（CPU）</h1>
<h2 id="51-cpu">5.1 CPU的功能和基本结构</h2>
<h2 id="52">5.2 指令的执行过程</h2>
<h2 id="53">5.3 数据通路的功能和基本结构</h2>
<h2 id="54">5.4 控制器的功能和工作原理</h2>
<h2 id="55">5.5 异常和中断机制</h2>
<h3 id="551">5.5.1 异常和中断的基本概念</h3>
<p><img alt="截屏2024-11-19 21.54.14" src="/Users/apple/Desktop/截图/截屏2024-11-19 21.54.14.png" /></p>
<h3 id="552">5.5.2 异常和中断的分类</h3>
<table>
<thead>
<tr>
<th><img alt="截屏2024-11-20 10.50.26" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.50.26.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="截屏2024-11-20 10.50.46" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.50.46.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-19 21.55.43" src="/Users/apple/Desktop/截图/截屏2024-11-19 21.55.43.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 10.01.17" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.01.17.png" /></td>
</tr>
</tbody>
</table>
<h3 id="553">5.5.3 异常和中断的检测与响应</h3>
<table>
<thead>
<tr>
<th><img alt="截屏2024-11-20 10.39.02" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.39.02.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="截屏2024-11-20 10.39.25" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.39.25.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 10.37.34" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.37.34.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 10.44.00" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.44.00.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 10.45.12" src="/Users/apple/Desktop/截图/截屏2024-11-20 10.45.12.png" /></td>
</tr>
</tbody>
</table>
<h2 id="56">5.6 指令流水线</h2>
<h3 id="561">5.6.1 指令流水线的基本概念</h3>
<h3 id="562">5.6.2 指令流水线的基本实现</h3>
<h3 id="563">5.6.3 结构冒险、数据冒险和控制冒险的处理</h3>
<h3 id="564">5.6.4 超标量和动态流水线的基本概念</h3>
<blockquote>
<p>2020真题 easy  25jc3 mid</p>
</blockquote>
<p>高级流水线技术充分利用指令级并行(instruction level parallelism,ILP)来提高流水线的性能。</p>
<blockquote>
<p>超流水线(super-pipelining)技术</p>
</blockquote>
<p>一种是超流水线(super-pipelining)技术,通过增加流水线级数来使更多的指令同时在流水线中重叠执行。超流水线并没有改变CPI的值,CPI还是1,但是,因为理想情况下流水线的加速比与流水段的数目成正比,所以,流水段越多,时钟周期越短,指令吞吐率越高。 因此,超流水线的性能比普通流水线好。但是,流水线级数越多,用于流水段寄存器的开销就越大,因而流水线级数是有限制的,不可能无限增加。</p>
<blockquote>
<p>多发射流水线(multiple issue pipelining)技术</p>
</blockquote>
<p>另一种是多发射流水线(multiple issue pipelining)技术,通过同时启动多条指令(如整数运算、浮点运算、存储器访问等)独立运行来提高指令并行性。要实现多发射流水线,其前提是数据通路中有多个执行部件,如定点、浮点、乘/除、取数/存数部件等。多发射流水线的CPI能达到小于1,因此,有时用CPI的倒数IPC来衡量其性能。IPC(instructions per cycle)是指每个时钟周期内完成的指令条数。例如,四路多发射流水线的理想IPC为4。</p>
<p>实现多发射流水线必须完成两个任务:指令打包和冒险处理。指令打包任务就是将能够并行处理的多条指令同时发送到发射槽中,因此处理器必须知道每个周期能发射几条指令,哪些指令可以同时发射。这通过推测(speculation)技术来完成,可以由编译器或处理器通过猜测指令执行结果来调整指令执行顺序,使指令的执行能达到最大可能的并行。指令打包的决策依赖于“推测”的结果,主要根据指令间的相关性来进行推测,与前面指令不相关的指令可以提前执行。例如,如果可以推测出一条load指令和它之前的store指令引用的不是同一个存储地址,则可以将load指令提前到store指令之前执行;也可对分支指令进行推测以提前执行分支目标处的指令。不过,推测仅是“猜测”,有可能推测错误,故需有推测错误检测和回退机制,在检测到推测错误时,能回退掉被错误执行的指令。因此,错误推测会导致额外开销。需要结合软件推测和硬件推测来进行,软件推测指编译器通过推测来静态重排指令,此种推测一定要正确;而硬件推测指处理器在程序执行过程中通过推测来动态调度指令。</p>
<p>根据推测打包任务主要由编译器静态完成还是由处理器动态执行,可将多发射技术分为两类:静态多发射和动态多发射。</p>
<blockquote>
<p>静态多发射处理器</p>
</blockquote>
<p>静态多发射处理器又称超长指令字(very long instruction word,VLIW)。</p>
<p>通常将一个周期内发射的多个指令看成一条多个操作的长指令,称为一个发射包。</p>
<blockquote>
<p>超标量和动态流水线</p>
</blockquote>
<p>超标量(superscalar)处理器又称==动态多发射处理器==。</p>
<p>对于静态多发射处理器的静态调度来说,编译结果与机器结构密切相关;</p>
<p>而对于动态调度来说,由于完全由硬件决定某个时钟周期发射哪几条指令,因而==编译器仅进行指令顺序调整,而不需要根据机器结构进行指令打包。==</p>
<p>为了更好地发挥超标量处理器的性能,多数超标量处理器都结合动态流水线调度(dynamic pipeline scheduling)技术,处理器通过指令相关性检测和动态分支预测等手段,==投机性地不按指令顺序执行==,当发生流水线阻塞时,根据指令的依赖关系,动态地到后面找一些没有依赖关系的指令提前执行。这种指令执行方式称为乱序执行(out-of-order execution)。</p>
<p>为了实现动态多发射和动态流水线调度,处理器中需要提供一些必要的机制和相应的处理部件,如指令预取部件、指令调度与分派部件、多个功能部件、重排序缓存等。图6.28 是动态多发射流水线处理器的通用模型示意图。</p>
<p><img alt="截屏2024-11-23 15.47.19" src="/Users/apple/Desktop/截图/截屏2024-11-23 15.47.19.png" /></p>
<p>(1)指令预取和译码单元。为了保证流水线中有足够的指令执行,必须要有指令预取功能。预取的指令经译码后,放到一个指令队列中。 (2)指令分派(dispatch)器。通过分析指令功能和指令间的依赖关系,并根据功能部件的空闲情况,确定何时发射哪条指令到哪个功能单元中。 (3)功能单元。超标量处理器中一定有多个功能单元,它们各自完成独立的操作,如整数部件(整数加减、整数乘、整数除)、浮点部件(浮点加减、浮点乘、浮点除)、存/取部件等。 每个功能单元都具有一定的操作性能,通常用两个周期数来刻画。一个是执行周期数(latency),表示完成特定操作所花的时钟周期数;另一个是发射时间(issue time),表示连续、独立的两次操作之间的最短周期数</p>
<p>(4)重排序缓冲(reorder buffer,ROB)。用于保存已完成的指令结果,等待在可能时写回寄存器堆。功能部件一旦完成操作,则将结果同时送其他等待该结果的保留站和ROB 中。指令结果也可在 ROB中被转发。当指令发射时,其源操作数可能是其他指令的运算结果,因而可能正在寄存器堆或 ROB中,此时可立即将操作数复制到相应的保留站中;若操作数不在寄存器堆或ROB中,则一定会在某个时刻由一个功能单元计算出来,硬件通过定位该功能单元,将结果从旁路转发到相应的保留站。</p>
<p>动态多发射流水线的执行模式有3种:按序发射、按序完成;按序发射、无序完成;无序发射、无序完成。</p>
<blockquote>
<p>3种模式不放心还要详细学</p>
</blockquote>
<h1 id="6">6 总线和输入输出系统</h1>
<h2 id="61">6.1 总线</h2>
<h3 id="611">6.1.1 总线的基本概念</h3>
<p><span class="arithmatex"><span class="MathJax_Preview">\color{red} 总线是计算机内数据传输的公共路径。</span><script type="math/tex">\color{red} 总线是计算机内数据传输的公共路径。</script></span>用于实现两个或两个以上部件之间<span class="arithmatex"><span class="MathJax_Preview">\color{red}分时共享</span><script type="math/tex">\color{red}分时共享</script></span>的信息交换。计算机系统中有多种总线,它们在各个层次上提供部件之间的连接和信息交换通路。</p>
<h3 id="612">6.1.2 总线的组成及性能指标</h3>
<blockquote>
<p>总线的性能指标</p>
</blockquote>
<p><img alt="截屏2024-11-18 14.08.07" src="/Users/apple/Desktop/截图/截屏2024-11-18 14.08.07.png" /></p>
<p>总线传输周期(bus transmission cycle) 总线传输周期是在总线上完成一次总线事务所用的时间,通常由若干总线时钟周期组成,简称总线周期。</p>
<p>总线带宽(bus bandwidth) 总线带宽就是总线的最大数据传输率,即总线在进行数据传输时单位时间内在总线上可传输的最大数据量。</p>
<blockquote>
<p>总线的组成</p>
</blockquote>
<p><img alt="截屏2024-11-18 14.25.03" src="/Users/apple/Desktop/截图/截屏2024-11-18 14.25.03.png" /></p>
<h3 id="613">6.1.3 总线事务和定时</h3>
<blockquote>
<p>总线事务(bus transaction)</p>
</blockquote>
<p>通常把在总线上一对设备之间的一次信息交换过程称为一个总线事务。把发出事务请求的部件称为主控设备或主设备(master),又称启动者(initiator),另一个部件称为从设备(slave),又称目标(target)。总线事务类型由其操作性质来定义。例如,存储器读事务是指将数据从主存取出到处理器,存储器写事务是指将数据写到主存。典型的总线事务类型有存储器读、存储器写、1/0读、1/0写、中断响应等。</p>
<p>总线事务类型指在总线上进行的不同信息传输类型,如存储器读、存储器写、1/0读、1/0写、中断响应等。有些总线事务要求完成一连串连续单元的读写,如从存储器读一个cache 行或写一个 cache 行到主存,这种情况下,一个总线事务完成多个数据的读写,称为突发(burst)传输方式。 在多个主控设备共享总线的情况下,需要进行总线裁决,有集中式裁决和分布式裁决两类。不过,目前总线的发展趋势是点对点连接方式,而不是早期多设备共享方式,所以无须考虑总线裁决。</p>
<h2 id="62-io-io">6.2 I/O 接口 （I/O控制器）</h2>
<p>I/0接口(I/0 interface, I/0 module) I/0接口(I/0模块)是主机和外设之间传送信息的“桥梁”,介于主机和外设之间。主机控制外设的命令信息、传送给外设的数据或从外设取来的数据以及外设送给主机的状态信息等都要先存放到1/0接口。对每种具体的设备来说,就是介于底板总线和通信总线(电缆式总线)之间的扩展卡或插件板,如网卡、显示卡等。也有很多设备的接口电路集成在主板上,如声卡、打印机控制卡、磁盘控制器、键盘/鼠标控制电路等已经基本上集成在主板上,只留一些电缆插座,以连接相应的外部设备。</p>
<p>1/0控制器(1/0 controller) 1/0控制器指 1/0接口中的控制电路,不包含1/O接口中的连接器插座。</p>
<p>1/0端口(1/0 port) 1/0接口中一些可被程序访问的寄存器用来存放控制(命令)、数据和状态等信息,这些寄存器称为1/0端口。</p>
<p>数据端口(data port) 在1/0接口中,用于存放接收和发送数据的寄存器称为数据端口,可以对其进行读或写操作。 </p>
<p>状态端口(status port) 在1/0接口中,用来记录外部设备或1/O接口的状态的寄存器称为状态端口,通常只可以对其进行读操作。有些接口电路,将命令端口和状态端口合二为一,作命令端口时, 从 CPU 写入控制信息;作为状态端口时,存入外设或接口的状态信息,供CPU 读取。</p>
<h3 id="621-io">6.2.1 I/O 接口的功能和基本结构</h3>
<p>I/O接口的职能可概括为以下几方面。</p>
<p>(1)数据缓冲。由于主存和CPU寄存器的存取速度非常快,而外设速度则较低,所以在I/O接口中引入数据缓冲寄存器,可以实现主机和外设工作速度的匹配。</p>
<p>(2)错误或状态检测。在I/O接口中提供状态寄存器,以保存各种状态信息,供CPU 查用。如设备是否完成打印或显示,是否已准备好输入数据以供主机来读取,是否发生缺纸等出错情况。接口和外设发生的出错情况有两类:一类是设备电路故障或异常情况;另一类是数据传输错,这种错误是通过采用数据校验码来检测的。</p>
<p>(3)控制和定时。提供控制和定时逻辑,以接收从I/O总线传来的控制命令(命令字) 和定时信号。</p>
<p>(4)数据格式转换。提供数据格式转换部件(如进行串-并转换的移位寄存器),使通过外部接口得到的数据转换为内部接口需要的格式,或在相反的方向进行数据格式转换。</p>
<p><img alt="截屏2024-11-18 13.34.39" src="/Users/apple/Desktop/截图/截屏2024-11-18 13.46.54.png" /></p>
<p><img alt="截屏2024-11-18 13.35.24" src="/Users/apple/Desktop/截图/截屏2024-11-18 13.35.24.png" /></p>
<h3 id="622-io">6.2.2 I/O 端口及其编址</h3>
<h2 id="63-io">6.3 I/O 方式</h2>
<p><img alt="截屏2024-11-17 16.38.23" src="/Users/apple/Desktop/截图/截屏2024-11-17 16.38.23.png" /></p>
<h2 id="631">6.3.1 程序查询方式</h2>
<p><img alt="截屏2024-11-17 16.48.49" src="/Users/apple/Desktop/截图/截屏2024-11-17 16.48.49.png" /></p>
<h3 id="633-dma">6.3.3 DMA 方式</h3>
<p>DMA 控制器的组成</p>
<p><img alt="截屏2024-11-17 15.44.46" src="/Users/apple/Desktop/截图/截屏2024-11-17 15.44.46.png" /></p>
<p><img alt="截屏2024-11-17 15.57.33" src="/Users/apple/Desktop/截图/截屏2024-11-17 15.57.33.png" /></p>
<p><img alt="截屏2024-11-17 15.57.22" src="/Users/apple/Desktop/截图/截屏2024-11-17 15.57.22.png" /></p>
<p>DMA 传送过程</p>
<p><img alt="截屏2024-11-17 16.08.46" src="/Users/apple/Desktop/截图/截屏2024-11-17 16.08.46.png" /></p>
<h1 id="_6">操作系统</h1>
<p><img alt="v2-cede730b16a8f1c1e62411440cb865c7_r" src="/Users/apple/Desktop/截图/v2-cede730b16a8f1c1e62411440cb865c7_r.jpeg" /></p>
<h1 id="1_2">1 操作系统基础</h1>
<h2 id="12_1">1.2 操作系统发展历程</h2>
<p><img alt="截屏2024-11-20 11.12.23" src="/Users/apple/Desktop/截图/截屏2024-11-20 11.12.23.png" /></p>
<h2 id="14">1.4 操作系统结构</h2>
<blockquote>
<p>分层 模块化 宏内核 微内核 外核</p>
</blockquote>
<table>
<thead>
<tr>
<th><img alt="截屏2024-11-20 12.47.02" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.47.02.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="截屏2024-11-20 12.47.24" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.47.24.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 12.47.35" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.47.35.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 12.47.49" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.47.49.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 12.48.30" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.48.30.png" /></td>
</tr>
</tbody>
</table>
<h2 id="15">1.5 操作系统引导</h2>
<p><img alt="截屏2024-11-20 11.05.40" src="/Users/apple/Desktop/截图/截屏2024-11-20 11.05.40.png" /></p>
<p><img alt="截屏2024-11-20 12.53.09" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.53.09.png" /></p>
<table>
<thead>
<tr>
<th><img alt="截屏2024-11-20 12.54.08" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.54.08.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="截屏2024-11-20 12.54.34" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.54.34.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 12.55.05" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.55.05.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-20 12.55.27" src="/Users/apple/Desktop/截图/截屏2024-11-20 12.55.27.png" /></td>
</tr>
</tbody>
</table>
<h1 id="3_1">3 内存管理</h1>
<h2 id="31_1">3.1 内存管理基础</h2>
<h3 id="311">3.1.1 内存管理的基本概念</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>考纲:</p>
<p>1.逻辑地址空间与物理地址空间，</p>
<p>2.地址变换，</p>
<p>3.内存共享，</p>
<p>4.内存保护，</p>
<p>5.内存分配与回收</p>
<p>4 内存保护</p>
</blockquote>
<p>为避免主存中多道程序相互干扰,防止某进程出错而破坏其他进程的正确性,或某进程不合法地访问其他进程的代码或数据区,应该对每个进程进行存储保护。</p>
<p>为了对操作系统的存储保护提供支持,硬件必须具有以下三种基本功能。</p>
<p>1 使部分CPU状态只能由操作系统内核程序写,而进程只能读不能写。2 支持至少两种特权模式。3提供让 CPU 在内核态和用户态之间相互转换的机制</p>
<p>访问权限保护。存储区域保护。</p>
<p>==1.访问权限保护==</p>
<p>访问权限保护就是看是否发生了迈问越权。</p>
<p>一般规定:各程序对本程序所在的存储区可读可写;对共享区或已获授权的其他用户信息可读不可写;而对未获授权的信息(如OS 内核、页表等)不可访问。通常,数据段可指定为可读可写或只读;程序段可指定只可执行或只读。</p>
<p>==2.存储区域保护。==</p>
<p>加界重定位。每个程序或程序段都记录有起始地址和终止地址,分别称为点界和下界。 对虚拟地址加界(即加基准地址)生成物理地址后,如果物理地址超过了上界和下界规定的范围,则地址越界。有些系统用专门的一对上界寄存器和下界寄存器来记录上界和下界,在分段式虚存中,通过段表来记录段的上界和下界。</p>
<p>键保护。操作系统为主存的每一个页框分配一个存储键,为每个用户进程设置一个程序键。进程运行时,将程序状态字寄存器中的键(程序键)和所访问页的键(存储键)进行核对,相符时才可访问,这两个键如同“锁”与“钥匙”的关系。为使某个页框能被所有进程访问,或某个进程可访问任何一个页框,可规定键标志为0,此时不进行核对工作。例如, 操作系统有权访问所有页框中的页面,因此,可让内核进程的程序键为0。</p>
<p>环保护。主存中各进程按其重要性分为多个保护级,各级别构成同心环,最内环的进程保护级别最高,向外逐次降低。内环进程可以访问外环和同环进程的地址空间,而外环不得访问内环进程的地址空间。内核程序的保护级别最高,环号最小,而用户程序都处于外环上。 IA-32 就采用该方案,操作系统内核工作在第0环(内核态),操作系统其他部分工作在第1 环,用户进程工作在第3环(用户态),留下第2环给中间软件使用。实际上,Linux 等操作系统只用了第0环和第3环。</p>
<p><img alt="截屏2024-11-21 16.59.43" src="/Users/apple/Desktop/截图/截屏2024-11-21 16.59.43.png" /></p>
<p><img alt="截屏2024-11-21 16.59.50" src="/Users/apple/Desktop/截图/截屏2024-11-21 16.59.50.png" /></p>
<blockquote>
<p>5.内存分配与回收</p>
</blockquote>
<p><img alt="截屏2024-11-21 17.22.38" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.22.38.png" /></p>
<h3 id="312">3.1.2 连续分配管理方式</h3>
<p><img alt="截屏2024-11-21 17.23.08" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.23.08.png" /></p>
<p>新增：伙伴算法(buddy system)</p>
<p><img alt="截屏2024-11-21 17.29.23" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.29.23.png" /></p>
<p><img alt="截屏2024-11-21 17.29.41" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.29.41.png" /></p>
<h3 id="313">3.1.3 页式管理</h3>
<h3 id="314">3.1.4 段式管理</h3>
<h3 id="315">3.1.5 段页式管理</h3>
<h2 id="32_1">3.2  虚拟内存管理</h2>
<h3 id="321">3.2.1 虚拟内存的基本概念</h3>
<p>在采用虚拟存储技术的计算机中,指令执行时,通过存储器管理部件(Memory Management Unil,简称MMU)将指令中的逻辑地址(也称虚拟地址或虚地址,简写为VA)转化为主存的物理地址(也称主存地址或实地址,简写为PA)。</p>
<p>虚拟存储技术既解决了编程空间受限的问题,又解决了多道程序共享主存带来的安全等问题。</p>
<p>虚拟存储机制为程序提供了一个极大的虚拟地址空间(也称为逻辑地址空间),它是主存和磁盘存储器的抽象。虚存机制带来了一个假象,使得每个进程好像都独占使用主存,并且主存空间极大。</p>
<p><img alt="截屏2024-11-21 16.00.37" src="/Users/apple/Desktop/截图/截屏2024-11-21 16.00.37.png" /></p>
<p><img alt="截屏2024-11-21 16.04.25" src="/Users/apple/Desktop/截图/截屏2024-11-21 16.04.25.png" /></p>
<p><img alt="截屏2024-11-21 17.02.34" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.02.34.png" /></p>
<p>任何时刻一个进程中的所有页面都被划分成三个不相交的页面集合:未分配页集合、缓存页集合和未缓存页集合。</p>
<h3 id="332">3.3.2 请求页式管理</h3>
<p>虚拟地址空间中的页称为虚拟页、逻辑页或虚页。虚拟页简称为 VP ( Virual Page)</p>
<p>主存空间中的页称为页框(页帧)、物理页或实页。PF(Page Frame) 或 PP(Physical Page)</p>
<p>根据磁盘的特性,磁盘扇区定位所用的时间要比磁盘读写一个数据的时间长大约100 000倍,也即对扇区第一个数据的读写比随后数据的读写要慢100000倍。</p>
<p>考虑到缺页代价的巨大和磁盘访问第一个数据的开销,通常将主存和磁盘之间交换的页的大小设定得比较大, 典型的有4KB 和8KB 等,而且有越来越大的趋势。</p>
<p>在处理一致性问题时,采用回写(write back)方式,而不用全写(write through)方式。</p>
<p>因为在虚拟存储机制中采用全相联映射,所以每个虚拟页可以存放到对应主存区域的任何一个空闲页框中。</p>
<blockquote>
<p>页表</p>
</blockquote>
<p>虛拟存储管理机制中用页表(page table)来描述这种对应关系。</p>
<p>页表项中的存放位置字段用来建立虚拟页和物理页框之间的映射,用于进行虚拟地址到物理地址的转换。装入位也称为有效或存在位,用来表示对应页面是否在主存,若为“1”, 表示该虚拟页已从外存调入主存,是一个“缓存页”,此时,存放位置字段指向主存物理页景(即页框号或实页号);若为“0”,则表示没有被调人主存,此时,若存放位置字段力null,则说明是一个“未分配页”,否则是一个“未缓存页”,其存放位置字段给出该虚拟页在磁盘上的起始地址。修改位(也称胜位)用来说明页面是否被修改过,虚存机制中采用回写策略,利用修改位可判断替换时是否需写回磁盘。使用位用来说明页面的使用情况,配合替换策略来设置,因此也称賛換控制位,例如,是否最先调人(FIFO位),是否最近最少用(LRU 位)等。迈问权限位用来说明页面是可读可写、只读还是只可执行等,用于存储保护。禁止缓存位用来说明页面是否可以装入 cache,通过正确设置该位,可以保证磁盘、主存和 cache 数据的一致性。</p>
<p>系统中每个进程都有一个页表,页表属于==进程控制信息==,存放在虚拟地址空间的内核空间,页表在主存的首地址记录在页表基址寄存器中。</p>
<p>解决页表过大的方法有很多,可以采用限制大小的一级页表或者两级页表、多级页表方式, 也可以采用哈希方式的倒置页表等方案。如何实现主要是操作系统考虑的问题,在此不多赘述。</p>
<blockquote>
<p>TLB</p>
</blockquote>
<p>在高速缓存中的页表项组成的页表称为后备转换缓冲器(Translation Lookaside Buffer,简称 TL.B),通常称为快表,相应地称主存中的页表为慢表。</p>
<p>而对于 TLB 缺失,则既可以用硬件也可以用软件来处理。用软件方式处理时,操作系统通过专门的TLB缺失异常处理程序来实现。</p>
<p><img alt="截屏2024-11-21 16.14.25" src="/Users/apple/Desktop/截图/截屏2024-11-21 16.14.25.png" /></p>
<h3 id="323">3.2.3 页框分配与回收</h3>
<blockquote>
<p>分配</p>
</blockquote>
<p>缺页中断函数 Page FaultHandler</p>
<blockquote>
<p>回收</p>
</blockquote>
<ol>
<li>
<p>后台内存回收 kswapd 异步</p>
</li>
<li>
<p>直接内存回收 direct reclaim 同步</p>
</li>
<li>
<p>大招: COM(Out of Memory) kiler机制</p>
</li>
</ol>
<p>页框回收(Page Frame Reclaiming Algorithm,PFRA)</p>
<p>文件页(File-backed Page)</p>
<p>匿名页(Anonymous Page)</p>
<p>基于LRU</p>
<p>回收页框基本会发生磁盘I/O</p>
<h3 id="324">3.2.4 页置换算法</h3>
<p><img alt="截屏2024-11-21 17.40.39" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.40.39.png" /></p>
<p><img alt="截屏2024-11-21 17.40.54" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.40.54.png" /></p>
<h3 id="325-memory-mapped-files">3.2.5 内存映射文件(memory-mapped files)</h3>
<blockquote>
<p>未考新考点</p>
</blockquote>
<p><img alt="截屏2024-11-21 17.41.17" src="/Users/apple/Desktop/截图/截屏2024-11-21 17.41.17.png" /></p>
<h3 id="326">3.2.6 虚拟存储器性能的影响因素及改进方法</h3>
<h1 id="4_2">4 文件管理</h1>
<h2 id="41_1">4.1 文件</h2>
<h3 id="413">4.1.3 文件的操作</h3>
<blockquote>
<p>建立，删除，打开，关闭，读，写</p>
</blockquote>
<table>
<thead>
<tr>
<th><img alt="截屏2024-11-19 19.11.39" src="/Users/apple/Desktop/截图/截屏2024-11-19 19.11.39.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="截屏2024-11-19 19.12.51" src="/Users/apple/Desktop/截图/截屏2024-11-19 19.12.51.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-19 19.15.25" src="/Users/apple/Desktop/截图/截屏2024-11-19 19.15.25.png" /></td>
</tr>
<tr>
<td><img alt="截屏2024-11-19 19.15.37" src="/Users/apple/Desktop/截图/截屏2024-11-19 19.15.37.png" /></td>
</tr>
</tbody>
</table>
<h2 id="43_1">4.3 文件系统</h2>
<p><img alt="截屏2024-11-19 16.55.53" src="/Users/apple/Desktop/截图/截屏2024-11-19 16.55.53.png" /></p>
<h3 id="433_1">4.3.3 虚拟文件系统</h3>
<p><img alt="截屏2024-11-19 17.09.54" src="/Users/apple/Desktop/截图/截屏2024-11-19 17.09.54.png" /></p>
<p><img alt="截屏2024-11-19 17.10.35" src="/Users/apple/Desktop/截图/截屏2024-11-19 17.10.35.png" /></p>
<h3 id="mounting">文件系统挂载(mounting)</h3>
<p><img alt="截屏2024-11-19 16.53.01" src="/Users/apple/Desktop/截图/截屏2024-11-19 16.53.01.png" /></p>
<p><img alt="截屏2024-11-19 19.32.27" src="/Users/apple/Desktop/截图/截屏2024-11-19 19.32.27.png" /></p>
<h1 id="5-io">5 输入/输出(I/O)管理</h1>
<h2 id="51-io">5.1 I/O 管理基础</h2>
<h3 id="513-io">5.1.3 I/O软件层次结构</h3>
<blockquote>
<p>中断处理程序，驱动程序，设备独立软件，用户层I/O软件</p>
</blockquote>
<p><img alt="截屏2024-11-18 15.02.32" src="/Users/apple/Desktop/截图/截屏2024-11-18 15.02.32.png" /></p>
<p><img alt="截屏2024-11-18 15.07.23" src="/Users/apple/Desktop/截图/截屏2024-11-18 15.07.23.png" /></p>
<p><img alt="截屏2024-11-18 15.32.23" src="/Users/apple/Desktop/截图/截屏2024-11-18 15.32.23.png" /></p>
<p><img alt="截屏2024-11-19 15.32.24" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.32.24.png" /></p>
<h3 id="514">5.1.4 输入/输出应用程序接口</h3>
<blockquote>
<p>又称应用程序接口 I/O 系统接口</p>
</blockquote>
<p><img alt="截屏2024-11-19 15.37.46" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.37.46.png" /></p>
<p><img alt="截屏2024-11-19 15.50.00" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.50.00.png" /></p>
<blockquote>
<p>字符设备接口</p>
</blockquote>
<p><img alt="截屏2024-11-19 15.28.09" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.28.09.png" /></p>
<p>字符设备是指数据的存取和传输是以字符为单位的设备,如键盘、打印机等。基本特征是传输速率较低、不可寻址,并且在输入/输出时通常采用中断驱动方式。 get 和 put 操作。由于字符设备不可寻址,只能采取顺序存取方式,通常为字符设备建立一个字符缓冲区,用户程序通过 get 操作从缓冲区获取字符,通过 put 操作将字符输出到缓冲区。 in-control 指令。字符设备类型繁多,差异甚大,因此在接口中提供一种通用的 in-control 指令来处理它们(包含了许多参数,每个参数表示一个与具体设备相关的特定功能)。 字符设备都属于独占设备,为此接口中还需要提供打开和关闭操作,以实现互斥共享。</p>
<blockquote>
<p>块设备接口</p>
</blockquote>
<p><img alt="截屏2024-11-19 15.40.57" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.40.57.png" /></p>
<p>块设备是指数据的存取和传输是以数据块为单位的设备,典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I/O 常采用 DMA方式。</p>
<p>内存映射接口通过内存的字节数组来访问磁盘,而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时,才由虚拟存储器实际调页。内存映射文件的访问如同内存读/写一样简单,极大地方便了程序员。</p>
<blockquote>
<p>网络设备接口</p>
</blockquote>
<p><img alt="截屏2024-11-19 15.41.09" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.41.09.png" /></p>
<p>许多操作系统提供的网络1/O 接口为网络套接字接口,套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字,通过此连接发送和接收数据。</p>
<p><img alt="截屏2024-11-19 15.47.40" src="/Users/apple/Desktop/截图/截屏2024-11-19 15.47.40.png" /></p>
<blockquote>
<p>阻塞/非阻塞I/O</p>
</blockquote>
<p>阻塞I/O优点:操作简单,实现难度低,适合并发量小的应用开发。 缺点:1/O执行阶段进程会一直阻塞下去。</p>
<p>非阻塞I/O优点:进程在等待1/O 期间不会阻塞,可以做其他事情,适合并发量大的应用开发。 缺点:轮询方式询问1/O结果,会占用 CPU 的时间。</p>
<p><img alt="截屏2024-11-18 16.57.35" src="/Users/apple/Desktop/截图/截屏2024-11-18 16.57.35.png" /></p>
<p><img alt="截屏2024-11-18 17.06.07" src="/Users/apple/Desktop/截图/截屏2024-11-18 17.06.07.png" /></p>
<p>可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了(进程或线程就阻塞在那了，不能做其它事情)，否则就可以理解为非阻塞(在等待的过程中可以做其它事情)。</p>
<blockquote>
<p>出自《Unix网络编程卷1：套接字联网API》</p>
</blockquote>
<h2 id="52_1">5.2 设备独立软件</h2>
<h3 id="521">5.2.1 缓冲区管理</h3>
<h3 id="522">5.2.2 设备分配与回收</h3>
<h3 id="523-spooling">5.2.3 假脱机技术(SPOOLing)</h3>
<p>SPOOLING 外部设备联机并行操作，即Simultaneous Peripheral Operations On-Line</p>
<p><img alt="截屏2024-11-24 13.47.10" src="/Users/apple/Desktop/截图/截屏2024-11-24 13.47.10.png" /></p>
<p><img alt="截屏2024-11-24 13.31.36" src="/Users/apple/Desktop/截图/截屏2024-11-24 13.31.36.png" /></p>
<p>要实现假脱机技术，必须要有多道程序技术的支持，建立输入进程和输出进程。</p>
<p><img alt="截屏2024-11-24 13.35.31" src="/Users/apple/Desktop/截图/截屏2024-11-24 13.35.31.png" /></p>
<p><img alt="截屏2024-11-24 13.34.57" src="/Users/apple/Desktop/截图/截屏2024-11-24 13.34.57.png" /></p>
<h3 id="524">5.2.4 设备驱动程序接口</h3>
<p><img alt="截屏2024-11-18 18.25.00" src="/Users/apple/Desktop/截图/截屏2024-11-18 18.25.00.png" /></p>
<blockquote>
<p>疑似实例更好理解</p>
</blockquote>
<h2 id="53_1">5.3 外存管理</h2>
<h3 id="531">5.3.1 磁盘的结构</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>磁盘结构</p>
<p>格式化</p>
<p>分区</p>
<p>磁盘调度算法</p>
<p>[!CAUTION]</p>
<p>磁盘结构</p>
</blockquote>
<p><img alt="截屏2024-11-24 14.40.00" src="/Users/apple/Desktop/截图/截屏2024-11-24 14.40.00.png" /></p>
<p>磁盘存储器主要由磁记录介质、磁盘驱动器、磁盘控制器3部分组成</p>
<blockquote>
<p>磁盘驱动器</p>
</blockquote>
<p><img alt="截屏2024-11-24 14.43.47" src="/Users/apple/Desktop/截图/截屏2024-11-24 14.43.47.png" /></p>
<p><img alt="截屏2024-11-24 14.47.12" src="/Users/apple/Desktop/截图/截屏2024-11-24 14.47.12.png" /></p>
<p>磁盘驱动器主要由多张硬盘片、主轴、主轴电机、移动臂、磁头和控制电路等部分组成。通过在接口插座上的电缆与磁盘控制器连接。每个盘片的两个面上各有一个磁头,因此,磁头号就是盘面号。磁头和盘片相对运动形成的圆,构成一个磁道(track), 磁头位于不同的半径上,则得到不同的磁道。多个盘面上的相同磁道形成一个柱面(cylinder),所以,磁道号就是柱面号。信息存储在每个盘面的磁道上,每个磁道被分成若干扇区(sector),以扇区为单位进行磁盘读写。</p>
<p>磁盘读写指根据磁盘地址寄存器中的盘地址(柱面号、磁头号、扇区号)读写目标磁道中的指定扇区。(1)寻道操作。(2)旋转等待操作。(3)读写操作。</p>
<blockquote>
<p>磁盘控制器</p>
</blockquote>
<p><img alt="截屏2024-11-24 14.54.45" src="/Users/apple/Desktop/截图/截屏2024-11-24 14.54.45.png" /></p>
<p>磁盘控制器是主机与磁盘驱动器之间的接口。</p>
<p>磁盘控制器包括，I/O接口，包括控制逻辑，时序电路，并串转换。</p>
<p>通常磁盘控制器位于主板上的芯片中,因而磁盘控制器直接和主板上的I/O总线相连接,I/O总线与其他系统总线(如处理器总线、存储器总线)之间用桥接器连接。磁盘驱动器与磁盘控制器之间的接口有多种,一般文件服务器使用SCSI接口,而普通的个人计算机前些年多使用并行 ATA(即IDE)接口,目前大多使用串行ATA(即SATA)接口。</p>
<p>磁盘存储器是高速外设,所以磁盘存储器和主机之间采用成批数据交换方式。</p>
<blockquote>
<p>磁记录介质</p>
</blockquote>
<p><img alt="截屏2024-11-24 14.57.33" src="/Users/apple/Desktop/截图/截屏2024-11-24 14.57.33.png" /></p>
<p>数据在磁盘上的记录格式分定长记录格式和不定长记录格式两种。目前大多采用定长记录格式。图7.17是温切斯特磁盘的磁道格式示意图,它采用定长记录格式。最早的硬盘由IBM公司开发,称为温切斯特盘(Winchester是一个地名),简称温盘,它是几乎所有现代硬盘产品的原型。</p>
<p>如图7.17所示,每个磁道由若干扇区(也称扇段)组成,每个扇区记录一个数据块,每个扇区有头空(间隙1)、ID域、间隙2、数据域和尾空(间隙 3)组成。头空占17字节,不记录数据,用全1表示,磁盘转过该区域的时间是留给磁盘控制器作准备用的;ID域有同步字节、磁道号、磁头号、扇段号和相应的CRC码(关于CRC码的概念参见7.4.4节)组成;数据域占515字节,有同步字节、数据和相应的CRC码组成,其中真正的数据区占512字节;尾空是在数据块的CRC 码后的区域,占20字节,也用全1表示。</p>
<h3 id="532">5.3.2 固态硬盘</h3>
<blockquote>
<p>[!IMPORTANT]</p>
<p>读写性能特性</p>
<p>磨损均衡</p>
</blockquote>
<h1 id="_7">计算机网络</h1>
<h1 id="1_3">1 计算机网络概述</h1>
<h2 id="11_2">1.1 计算机网络基本概念</h2>
<h3 id="111_1">1.1.1 计算机网络的定义、组成与功能</h3>
<blockquote>
<p>定义</p>
</blockquote>
<p>internet(互连网)是一个通用名词,泛指由多个计算机网络互连而成的计算机网络。在这些网络之间可以使用任意的通信协议作为通信规则,不一定非要使用TCP/IP 协议。 Internet(互联网或因特网)则是一个专用名词,指当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络,它采用 TCP/P 协议族作为通信规则。</p>
<p><img alt="截屏2024-11-24 19.30.04" src="/Users/apple/Desktop/截图/截屏2024-11-24 19.30.04.png" /></p>
<blockquote>
<p>组成</p>
</blockquote>
<p><img alt="截屏2024-11-24 19.32.14" src="/Users/apple/Desktop/截图/截屏2024-11-24 19.32.14.png" /></p>
<p><img alt="截屏2024-11-24 19.31.32" src="/Users/apple/Desktop/截图/截屏2024-11-24 19.31.32.png" /></p>
<h3 id="112_1">1.1.2 计算机网络的分类</h3>
<h3 id="113_1">1.1.3 计算机网络的主要性能指标</h3>
<h2 id="12_2">1.2 计算机网络体系结构</h2>
<h3 id="121">1.2.1 计算机网络分层结构</h3>
<h3 id="122">1.2.2 计算机网络协议、接口、服务等概念</h3>
<h3 id="123-isoositcpip">1.2.3 ISO/OSI参考模型和TCP/IP参考模型</h3>
<h1 id="4_3">4 网络层</h1>
<h2 id="41_2">4.1 网络层的功能</h2>
<h3 id="413-sdn">4.1.3 SDN基本概念</h3>
<blockquote>
<p>2022真题 easy</p>
</blockquote>
<p>路由器之间传送的信息有以下两大类: 第一类是转发源主机和目的主机之间所传送的数据,把源主机所发送的分组,像接力赛跑那样从一个路由器转发到下一个路由器,最后把分组传送到目的主机。 第二类则是传送路由信息,是根据路由选择协议所使用的路由算法,彼此不断地交换路由信息分组,目的是为了在路由器中创建路由表,并由此导出为转发分组而用的转发表。 这一类信息的传送是为第一类数据的传送服务的。</p>
<p>把网络层抽象地划分为数据层面(或转发层面)和控制层面。</p>
<p>在数据层面中,每一个路由器根据本路由器生成的转发表,把收到的分组,从查找到的对应接口转发出去。为了加快转发的速率,现在的路由器通常都采用硬件进行转发,转发一个分组的时间为纳秒(10°秒)数量级。</p>
<p>但在控制层面中的情况则不同。一个路由器不可能独自创建出路由表。路由器必须和相邻的路由器经常交换路由信息,然后才能创建出本路由器的路由表。根据路由选择协议所用的路由算法计算路由要使用软件,这就慢多了,一般是秒的数量级。</p>
<p>数据层面独立，控制层面协同。</p>
<h1 id="_8">串联内容</h1>
<h2 id="_9">操作系统引导</h2>
<p><img alt="截屏2024-11-20 11.05.40" src="/Users/apple/Desktop/截图/截屏2024-11-20 11.05.40.png" /></p>
<p>1.POST</p>
<p>CPU RESET引脚产生逻辑值复位CPU，CPU在0xFFFFFFF0处执行长跳转指令，跳转至固化在ROM中的代码启动处即<code>BIOS</code></p>
<p>BIOS中包括，自诊断程序，CMOS设置程序，系统自动装载程序，主要I/O驱动程序和中断服务程序。</p>
<p>第一步，硬件自检(Power-On Self-Test)</p>
<p>BIOS 将按<code>BOOT Sequence</code>,把控制权交给第一顺位储存设备（硬盘，软盘），读取启动设备的<code>MBR</code>并且放入指定位置<code>(0x7c00)</code>内存中。</p>
<p>计算机读取该设备第一个扇区(前512B)，最后两字节为签名，通常为<code>0x55</code>和<code>0xAA</code></p>
<p>前512B即主引导记录</p>
<p>2.主引导记录</p>
<p>作用，告诉计算机区硬盘的哪个位置去找操作系统。</p>
<p>主引导记录的组成如下。</p>
<p>1B-446B 调用操作系统的机器码</p>
<p>447B-510B 分区表(Partition table)</p>
<p>511B-512B 主引导记录签名</p>
<p>主引导记录需要知道将控制权交给哪个区</p>
<p>分区表共64B，共四项，每项16B，代表一个主分区。最多4个主分区。</p>
<p>每个主分区16B，由6个部分组成</p>
<p>1B 是否为<code>0x80</code>，若是则为激活分区，下一阶段的控制权主体。</p>
<p>2B-4B 主分区第一个扇区的物理位置</p>
<p>5B 主分区类型</p>
<p>6B-8B 主分区最后一个扇区的物理位置</p>
<p>9B-12B 该主分区第一个扇区的逻辑地址</p>
<p>13B-16B 主分区扇区总数</p>
<p>由主分区扇区总数可知，扇区总数最多<span class="arithmatex"><span class="MathJax_Preview">2^{32}</span><script type="math/tex">2^{32}</script></span>个。</p>
<p>若每个扇区<span class="arithmatex"><span class="MathJax_Preview">512B</span><script type="math/tex">512B</script></span>则，最大空间<span class="arithmatex"><span class="MathJax_Preview">2TB</span><script type="math/tex">2TB</script></span></p>
<p>3.硬盘启动</p>
<p>三种情况。</p>
<p>A.操作系统位于主分区</p>
<p>读取<code>激活分区</code>的第一个扇区，叫做<code>卷引导记录</code>(VBR,PBR)</p>
<p>PBR告诉计算机操作系统在这个分区的哪个位置。</p>
<p>B.操作系统位于扩展分区和逻辑分区</p>
<p>最多四个主分区。但是有且仅有一个区可以定义为扩展分区。</p>
<p>计算机先读取扩展分区的第一个扇区，称<code>EBR</code>包含一张64B的分区表。</p>
<p>C.启动管理器</p>
<p>将控制权交给<code>boot loader</code>，启动管理器。</p>
<p>4.操作系统</p>
<p>PBR中找操作系统程序，控制权交给操作系统。</p>
<p>Linux首先载入<code>/boot</code>目录下<code>kernel</code></p>
<p>内核加载成功后运行<code>/sbin/init</code>。根据<code>etc/initab</code>产生<code>init</code>进程。</p>
<p>这是操作系统的第一个进程。<code>pid=1</code>。其他进程都是他的后代。</p>
<p>然后init线程加载操作系统的各个模块。如窗口程序和网络程序。</p>
<p>执行<code>bin/login</code>程序，跳出登陆界面。</p>
<h1 id="_10">参考文献与致谢</h1>
<p>1.2025年全国硕士研究生招生考试计算机学科专业基础考试大纲</p>
<p>2.王道咸鱼PPT</p>
<p>3.王道复习全书</p>
<p>4.清华大学操作系统PPT</p>
<p>5.INTEL微处理器(原书第八版)</p>
<p>6.xv6中文文档</p>
<p>7.深入理解LINUX内核(第三版)</p>
<p>8.湖南科技大学高军老师计算机网络PPT</p>
<p>9.计算机网络/谢希仁编著.一7版.一北京:电子工业出版社,2017.1 “十二五”普通高等教育本科国家级规划教材</p>
<p>10.计算机网络/谢希仁编著.—8版.一北京:电子工业出版社,2021.6 ISBN 978-7-121-41174-8</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>