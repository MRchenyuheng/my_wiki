# 2-SAT

$x_{1} \or x_{2}$ = 1 

求解 2-SAT

x_{1} = 1 x_{2} = 1 x_{3} = 1
x_{1} = 0 x_{2} = 1 x_{3} = 1

x_{1} = 1 \or x_{2} = 0

x_{1} = 1 -> x_{2} = 1
x_{1} = 0 -> x_{2} = 0

x_{i} = 1 -> x_{i} = 0 x_{i} = 1
x_{i} = 0 -> x_{i} = 1

图 咕咕咕

x_{i} 与 非x_{i} 在同一个强连通分量 scc 就矛盾了

当所有 x_{i} 与 非x_{i}都不在一个强连通分量

选拓扑序靠后

## 满汉全席

### 题目描述


大会的规则如下：每位参赛的选手可以得到 $n$ 种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。

大会的评审制度是：共有 $m$ 位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位选手。

换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： 

```
评审一 评审二 评审三 评审四 
满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 
汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 
```

如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。

但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。

如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： 

```
评审一 评审二 评审三 评审四 
满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 
汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 
```

所以大会希望有人能写一个程序来判断，所选出的 $m$ 位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。

### 输入格式

第一行包含一个数字 $K$（$1\le K \le 50$），代表测试文件包含了 $K$ 组数据。

每一组测试数据的第一行包含两个数字 $n$ 跟 $m$（$n≤100$，$m≤1000$），代表有 $n$ 种材料，$m$ 位评审员。

为方便起见，舍弃做法的中文名称而给予编号，编号分别从 $1$ 到 $n$。

接下来的 $m$ 行，每行都代表对应的评审员所拥有的两个喜好，每个喜好由一个英文字母跟一个数字代表，如 $m1$ 代表这个评审喜欢第 $1$ 个材料透过满式料理做出来的菜，而 $h2$ 代表这个评审员喜欢第 $2$ 个材料透过汉式料理做出来的菜。

```cpp
const int N = 101000;
vector<int> e[N];

int dfn[N], low[N], ins[N], bel[N], idx, n, m, cnt;
stack<int> stk;

void dfs(int u) {
	dfn[u] = low[u] = ++idx;
	ins[u] = true;
	stk.push(u);
	for (auto v : e[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[u], low[v]);
	}
	if (dfn[u] == low[u]) {
		++cnt;
		while (true) {
			int v = stk.top();
			ins[v] = false;
			bel[v] = cnt;
			stk.pop();
			if (v == u) break;
		}
	}
}

void solve() {
	scanf("%d%d ", &n, &m);
	// 0 .. 2n-1  i,   mi   2 * i, hi 2 * i + 1
	for (int i = 0; i < 2 * n; i++)
		dfn[i] = 0, e[i].clear();
	idx = cnt = 0;
	for (int i = 0; i < m; i++) {
		char ty1, ty2;
		int u, v;
		scanf("%c%d %c%d ", &ty1, &u, &ty2, &v);
		--u; --v;
		u = u * 2 + (ty1 == 'h');
		v = v * 2 + (ty2 == 'h');
		e[u ^ 1].push_back(v);
		e[v ^ 1].push_back(u);
	}
	for (int i = 0; i < 2 * n; i++) if (dfn[i] == 0)
		dfs(i);
	for (int i = 0; i < n; i++) {
		// bel[2 * i] < bel [2 * i + 1] 选 2 * i
		if (bel[2 * i] == bel[2 * i + 1]) {
			puts("BAD");
			return;
		}
	}
	puts("GOOD");
}
```